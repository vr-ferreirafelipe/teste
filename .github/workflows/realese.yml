name: Genarete Tag

on:
  workflow_dispatch:
  push:
    branches:
      - main

jobs:
  call-check-commit:
    name: Call Check Commit
    uses: ./.github/workflows/check-commits.yml
    secrets:
      VRPACKAGETOKEN: ${{ secrets.VRPACKAGETOKEN }}

  generate-version:
    name: Generate Tag
    if: needs.call-check-commit.outputs.has_changes
    needs: call-check-commit
    outputs:
      version: ${{ job.tag }}
      current_version: ${{ job.current_version }}
      has_release: ${{ job.has_release }}
    
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v2
        with:
          token: ${{ secrets.VRPACKAGETOKEN }}
          fetch-depth: 0
          ref: main

      - name: Git Config
        run: git config --global user.email "${GITHUB_ACTOR}@users.noreply.github.com" && git config --global user.name "${GITHUB_ACTOR}"
        
      - name: Get Current Tag 
        id: get_current_tag
        run: |
          # Inicialize uma variável de versão com a última tag
          CURRENT_VERSION=$(git describe --tags --abbrev=0 | sed 's/^v//')
          echo "::set-output name=current_version::$CURRENT_VERSION"

      - name: Check Version 
        id: check_version
        run: |
          echo "PASSOU NO Check Version "
          HAS_RELEASE=true

          COMMIT_MESSAGES="${{ needs.call-check-commit.outputs.commit_message }}"
          VERSION=${{ steps.get_current_tag.outputs.current_version }}

          MAJOR_VERSION=$(echo "$VERSION" | cut -d. -f1)
          MINOR_VERSION=$(echo "$VERSION" | cut -d. -f2)
          PATCH_VERSION=$(echo "$VERSION" | cut -d. -f3)

          if [[ $COMMIT_MESSAGES =~ "BREAKING CHANGE" ]]; then
            # Gera nova tag MAJOR
            NEW_VERSION="$((MAJOR_VERSION + 1)).0.0"
          elif [[ $COMMIT_MESSAGES =~ "feat" ]]; then
            # Gera nova tag MINOR
            NEW_VERSION="$MAJOR_VERSION.$((MINOR_VERSION + 1)).0"
          elif [[ $COMMIT_MESSAGES =~ "fix" ]]; then
            # Gera nova tag patch
            NEW_VERSION="$MAJOR_VERSION.$MINOR_VERSION.$((PATCH_VERSION + 1))"
          else
            # Nenhum commit gerará uma nova release
            echo "Nenhum commit nesta push gerará uma nova release."
            NEW_VERSION=""
            HAS_RELEASE=false
          fi 

          echo "::set-output name=has_release::$HAS_RELEASE"
          echo "::set-output name=new_version::$NEW_VERSION"
        shell: bash

      - name: Check New Release 
        id: check_new_release
        if: steps.check_version.outputs.has_release == 'true'
        run: |
          $IS_VALID_VERSION=false

          CURRENT_VERSION=${{ steps.get_current_tag.outputs.current_version }}
          echo "CURRENT_VERSION $CURRENT_VERSION"
          $CURRENT_MAJOR_VERSION=$(echo "$CURRENT_VERSION" | cut -d. -f1)
          $CURRENT_MINOR_VERSION=$(echo "$CURRENT_VERSION" | cut -d. -f2)
          $CURRENT_PATCH_VERSION=$(echo "$CURRENT_VERSION" | cut -d. -f3)
          
          NEW_VERSION=${{ steps.check_version.outputs.new_version }}
          echo "CURRENT_VERSION $NEW_VERSION"
          $NEW_MAJOR_VERSION=$(echo "$NEW_VERSION" | cut -d. -f1)
          $NEW_MINOR_VERSION=$(echo "$NEW_VERSION" | cut -d. -f2)
          $NEW_PATCH_VERSION=$(echo "$NEW_VERSION" | cut -d. -f3)

          if [[ $NEW_MAJOR_VERSION > CURRENT_MAJOR_VERSION ]]; then
            IS_VALID_VERSION=true
          elif [[ $NEW_MAJOR_VERSION == CURRENT_MAJOR_VERSION ]] && [[ $NEW_MINOR_VERSION > CURRENT_MINOR_VERSION ]]; then
            IS_VALID_VERSION=true
          elif [[ $NEW_MINOR_VERSION == CURRENT_MINOR_VERSION ]] && [[ $NEW_PATCH_VERSION > CURRENT_PATCH_VERSION ]]; then
            IS_VALID_VERSION=true
          fi

          echo "::set-output name=is_valid_version::$IS_VALID_VERSION"

      - name: Upgrade Release
        id: updagrade_release
        if: steps.check_new_release.outputs.is_valid_version == 'true'
        run: |
          NEW_VERSION=${{ steps.check_version.outputs.new_version }}
          npm --no-git-tag-version version $NEW_VERSION
          git add . 
          git commit -m "Entrega da versão $NEW_VERSION"

      - name: Create Release
        id: create_release
        if: steps.check_version.outputs.has_release == 'true' && steps.check_new_release.outputs.is_valid_version == 'true'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.VRPACKAGETOKEN }}
        with:
          tag_name: ${{ steps.check_version.outputs.new_version }}
          release_name: Release ${{ steps.check_version.outputs.new_version }}

      # - name: Generate Version
      #   run: |
      #     OLD_VERSION=${{ steps.get_current_tag.outputs.current_version }}
      #     NEW_VERSION=${{ steps.check_version.outputs.new_version }}

      #     echo $OLD_VERSION
      #     echo $NEW_VERSION

      #     # if [ "$OLD_VERSION" = "$NEW_VERSION" ]; then
      #     #   # As versões são diferentes, forçar uma nova tag no Git com a versão antiga
      #     #   # git tag -f $OLD_VERSION
      #     #   echo "versões iguais"
      #     # else
      #     #   # As versões são iguais, apenas atualize a versão usando npm
      #     #   npm version $NEW_VERSION -m "ci: release v$NEW_VERSION"
      #     # fi
          
      #     git log --tags -3


# jobs:
#   check-commit:
#     name: Check Commit
#     runs-on: ubuntu-latest
#     outputs:
#       count: ${{ steps.check_changes.outputs.has_changes }}
#       exist: ${{ steps.get_commits.outputs.commit_msg }}
#       status: ${{ job.status }}

#     steps:
#       - name: Checkout
#         uses: actions/checkout@v2

#       - name: Check Changes
#         id: check_changes
#         run: |
#           # Obtenha a quantidade de novos commits
#           COMMIT_COUNT=$(git rev-list $(git describe --tags --abbrev=0 @^)..@ --count)

#           # Set output has_changes
#           echo "::set-output name=has_changes::$([ "$COMMIT_COUNT" -gt 0 ] && echo "true" || echo "false")"

#       - name: Get Commit Messages
#         id: check-commits
#         if: steps.check_changes.outputs.has_changes == 'true'
#         run: |
#           # # Obtenha as mensagens de commit desde o último tag
#           COMMIT_MESSAGES=$(git log $(git describe --tags --abbrev=0 @^)..@ --pretty=format:%B)

#           # Set output commit_message
#           echo "::set-output name=commit_message::$COMMIT_MESSAGES"

#       - name: Tag
#         id: tag
#         if: steps.check-commits.outputs.commit_message != ''
#         run: |
#           # Inicialize uma variável de versão com a última tag
#           echo "::set-output name=current_version::$(git describe --tags --abbrev=0)"

      # - name: Generate Tag
      #   id: generate-tag
      #   if: ${{ needs.check-commits.outputs.commit_message != '' }}
      #   run: |
      #     echo "teste"

      #     # Inicialize uma variável de com os novos commits
      #     COMMIT_MESSAGES="${{ needs.check-commits.outputs.commit_message }}"
      #     echo $COMMIT_MESSAGES

      #     # Inicialize uma variável de versão com a última tag
      #     VERSION=$(git describe --tags --abbrev=0)
      #     echo "::set-output name=versao_atual::${VERSION}"
      #     echo=$VERSION

      #     if [[ $COMMIT_MESSAGES =~ "BREAKING CHANGE" ]]; then
      #       # Gera nova tag MAJOR
      #     echo "::set-output name=nova_versao::${VERSION%%.*}.$((${VERSION#*.} + 1)).${VERSION##*.}"
      #     elif if [[ $COMMIT_MESSAGES =~ "feat" ]]; then
      #       # Gera nova tag MINOR
      #       echo "::set-output name=nova_versao::${VERSION%%.*}.$((${VERSION#*.} + 1)).${VERSION##*.}"
      #     elif if [[ $COMMIT_MESSAGES =~ "fix" ]]; then
      #       # Gera nova tag PATCH
      #       echo "::set-output name=nova_versao::${VERSION%%.*}.$((${VERSION#*.} + 1)).${VERSION##*.}"
      #     else
      #       # Nenhum commit gerará uma nova release
      #       echo "Nenhum commit nesta push gerará uma nova release."
      #       echo "::set-output name=nova_versao::${VERSION}"
      #     fi 
      #   shell: bash

      # - name: Generate Version
      #   id: generate-version
      #   if: ${{ steps.generate-tag.outputs.versao_atual != steps.generate-tag.outputs.nova_versao }}
      #   run: |
      #     should_bump="${{ steps.check-commits.outputs.should_bump }}"
          
      #     if [ "$should_bump" == "major" ]; then
      #       npm version major
      #     elif [ "$should_bump" == "minor" ]; then
      #       npm version minor
      #     elif [ "$should_bump" == "patch" ]; then
      #       npm version patch
      #     else
      #       echo "Nenhum commit nesta push gerará uma nova release."
      #     fi

      # - name: Set Bump Type
      #   id: set-bump-type
      #   run: |
      #     bump_type="${{ needs.check-commit-messages.outputs.type_version }}"
      #     npm version $bump_type  # Isso aumentará a versão com base no tipo (major, minor ou patch)


      # - name: Commit and Push Version Bump
      #   if: steps.check-commits.outputs.should_bump == 'true'
      #   run: |
      #     git config user.name "Seu Nome"
      #     git config user.email "seu@email.com"
      #     git push --follow-tags